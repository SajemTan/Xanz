<html>
  <head>
    <title>Xanz Lexicon</title>
    <script type="text/javascript" src="lexicon.js"></script>
    <meta charset="UTF-8" />
    <style>
      .conjugation > .conjugation {
          padding-left: 20px;
      }
    </style>
  </head>
  <body onload="doSearch();">
    <div style="width: 100%; background-color: rgba(255, 255, 255, 0.9); position: fixed; left: 0px; top: 0px; padding: 15px;">
      <span>Search</span>
      <select id="searchwhat" onchange="doSearch();">
        <option value="all">Everything</option>
        <option value="root">Roots</option>
        <option value="def">Definitions</options>
      </select>
      <span>for</span>
      <input type="text" id="search" onkeyup="doSearch();"></input>
      <label for="regex">Regex? </label>
      <input type="checkbox" id="regex" onclick="doSearch();"></input>
    </div>
    <br>
    <br>
    <br>
    <br>
    <table border="1">
      <thead>
        <tr>
          <th>Root</th>
          <th>Definition</th>
        </tr>
      </thead>
      <tbody id="defs"></tbody>
    </table>
    <p id="matches"></p>
    <script>
      var search_all = [];
      var search_root = [];
      var search_defs = [];
      var search_nodes = [];
      var lexicon_flat_arr = lexicon.root.concat(lexicon.non_root);
      var searchMatch = function(txt, queryString, isRegex) {
        function decodeHtml(html) {
          var txt = document.createElement("textarea");
          txt.innerHTML = html;
          return txt.value;
        }
        var str = decodeHtml(txt);
        var find = decodeHtml(queryString);
        if (!isRegex) {
          return str.toLowerCase().includes(find.toLowerCase());
        } else {
          return str.match(queryString) != null;
        }
      };
      var doSearch = function() {
        var searchstr = document.getElementById("search").value;
        var isRegex = document.getElementById("regex").checked;
        var l = search_nodes;
        var srch;
        var mode = document.getElementById('searchwhat').value;
        if (mode == 'all') {
          srch = search_all;
        } else if (mode == 'root') {
          srch = search_root;
        } else if (mode == 'def') {
          srch = search_defs;
        }
        var matches = 0
        for (var i = 0; i < l.length; i++) {
          l[i].style.display = searchMatch(srch[i], searchstr, isRegex) ? "" : "none";
          if (l[i].style.display == "") { matches++; }
        }
        document.getElementById("matches").innerHTML = matches + " matches for " + searchstr;
      };
      var setSearch = function(str) {
        document.getElementById("search").value = str;
        doSearch();
      }
      var makeLink = function(word, update) {
        return "<a href=\"#\" onclick=\"setSearch('" + word + "')\">" + word + "</a>";
      };
      var mkel = function(tag, html) {
        var ret = document.createElement(tag);
        ret.innerHTML = html;
        return ret;
      };
      var tricons = function(c1, v1, c2, v2, c3, v3) {
          var nasals = {
              p: 'mh',
              b: 'm',
              t: 'nh',
              d: 'n',
              s: 'ñh',
              z: 'ñ',
              g: 'ng',
              á: 'a',
              é: 'e',
              í: 'i',
              ó: 'o',
              ý: 'y',
              éú: 'eu'
          };
          var ret = c1;
          if (nasals.hasOwnProperty(v1) && nasals.hasOwnProperty(c2)) {
              ret += nasals[v1];
              ret += nasals[c2];
          } else {
              ret += v1;
              ret += c2;
          }
          if (nasals.hasOwnProperty(v2) && nasals.hasOwnProperty(c3)) {
              ret += nasals[v2];
              ret += nasals[c3];
          } else {
              ret += v2;
              ret += c3;
          }
          ret += v3;
          return ret;
      };
      var conjugate = function(prev, mode) {
          var pmode = prev[prev.length-1][0];
          var pform = prev[prev.length-1][1];
          var patterns = {
              agentive: ['á', '', 'e'],
              intensive: ['a', 'a', ''],
              passive: ['á', 'e', ''],
              stative: ['a', 'i', ''],
              perfective: ['e', 'á', ''],
              patient: ['e', 'y', ''],
              middle: ['eu', 'eu', ''],
              witnessive: ['eu', 'éú', ''],
              instrument: ['ó', 'a', ''],
              active: ['u', 'í', ''],
              causative: ['y', 'o', '']
          };
          if (patterns.hasOwnProperty(mode)) {
              let v = patterns[mode];
              return tricons(pform[0], v[0], pform[1], v[1], pform[2], v[2]);
          } else if (mode == 'participle') {
              return pform + 'el';
          }
          if (typeof pform == "string") {
              return pform + '-' + mode;
          } else {
              console.log(pform);
              return pform.join('_');
          }
      };
      var makeList = function(ls) {
          var ret = mkel('ul', '');
          ls.forEach(function(s) {
              ret.appendChild(mkel('li', s));
          });
          return ret;
      };
      var makeBox = function(conj, blob, prev) {
          var ret = mkel('div', '');
          ret.className = 'conjugation';
          var pth = prev.concat([[conj, conjugate(prev, conj)]]);
          ret.appendChild(mkel('b', conj + ": " + pth[pth.length-1][1]));
          ret.appendChild(makeList(blob.gloss));
          if (blob.note.length) {
              ret.appendChild(mkel('b', 'Notes:'));
              ret.appendChild(makeList(blob.note));
          }
          for (var k in blob) {
              if (k == 'gloss' || k == 'note') {
                  continue;
              }
              ret.appendChild(makeBox(k, blob[k], pth));
          }
          return ret;
      };
      var makeRow = function(blob) {
        var retel = document.createElement('tr');
          var stem;
          if (blob.hasOwnProperty('root')) {
              stem = blob.root.join('-');
          } else {
              stem = blob.stem;
          }
          retel.id = stem;
        retel.setAttribute('data-json', escape(JSON.stringify(blob)));
        retel.setAttribute('data-word', stem);
        retel.appendChild(mkel('td', "<b>" + stem + "</b><br/>" + blob.gloss));
        var ret = document.createElement('td');
          retel.appendChild(ret);
          if (blob.hasOwnProperty('root')) {
              var prev = [["root", blob.root]];
              for (var k in blob.conj) {
                  ret.appendChild(makeBox(k, blob.conj[k], prev));
              }
          }
        var ul;
        var df;
        return retel;
      };
      var setup = function() {
        var defs = document.getElementById('defs');
        defs.innerHTML = '';
        for (var i = 0; i < lexicon_flat_arr.length; i++) {
          defs.appendChild(makeRow(lexicon_flat_arr[i]));
        }
        search_nodes = document.getElementById("defs").childNodes;
        var s;
        var node;
        var df;
        for (var i = 0; i < search_nodes.length; i++) {
          s = '';
          node = search_nodes[i];
          search_all.push(node.outerHTML);
          search_root.push(node.id);
          df = node.getElementsByClassName('def');
          for (var j = 0; j < df.length; j++) {
            s += df[j].innerHTML + ' ';
          }
          search_defs.push(s);
        }
      };
      setup();
    </script>
  </body>
</html>
